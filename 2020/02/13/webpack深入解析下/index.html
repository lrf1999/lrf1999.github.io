<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>webpack深入解析下 | codeLinR的博客</title><meta name="description" content="loader的使用 目前，webpack帮助我们处理的都是js文件。 但我们前面提过，webpack可以将js、图片、css都当成模块来进行处理，下面我们就来学习一下如何处理它们。  css文件处理css准备的阶段项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。  在src目录中，创建一个css文件，其中创建一个normal.css文件。 我们也可以重新组织文件的目"><meta name="keywords" content="webpack,模块打包"><meta name="author" content="codeLinR"><meta name="copyright" content="codeLinR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="webpack深入解析下"><meta name="twitter:description" content="loader的使用 目前，webpack帮助我们处理的都是js文件。 但我们前面提过，webpack可以将js、图片、css都当成模块来进行处理，下面我们就来学习一下如何处理它们。  css文件处理css准备的阶段项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。  在src目录中，创建一个css文件，其中创建一个normal.css文件。 我们也可以重新组织文件的目"><meta name="twitter:image" content="https://gitee.com/lin_risheng/assetOne/raw/master/images/webpack_logo.jpg"><meta property="og:type" content="article"><meta property="og:title" content="webpack深入解析下"><meta property="og:url" content="http://linrisheng.cn/2020/02/13/webpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%8B/"><meta property="og:site_name" content="codeLinR的博客"><meta property="og:description" content="loader的使用 目前，webpack帮助我们处理的都是js文件。 但我们前面提过，webpack可以将js、图片、css都当成模块来进行处理，下面我们就来学习一下如何处理它们。  css文件处理css准备的阶段项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。  在src目录中，创建一个css文件，其中创建一个normal.css文件。 我们也可以重新组织文件的目"><meta property="og:image" content="https://gitee.com/lin_risheng/assetOne/raw/master/images/webpack_logo.jpg"><meta property="article:published_time" content="2020-02-12T23:09:04.000Z"><meta property="article:modified_time" content="2020-05-14T23:51:40.788Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://linrisheng.cn/2020/02/13/webpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%8B/"><link rel="prev" title="Vuejs知识体系巩固整理" href="http://linrisheng.cn/2020/04/15/Vuejs%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%B7%A9%E5%9B%BA%E6%95%B4%E7%90%86/"><link rel="next" title="webpack深入解析 上" href="http://linrisheng.cn/2020/02/12/webpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#loader的使用"><span class="toc-number">1.</span> <span class="toc-text">loader的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#css文件处理"><span class="toc-number">1.1.</span> <span class="toc-text">css文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#css准备的阶段"><span class="toc-number">1.1.1.</span> <span class="toc-text">css准备的阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#认识loader"><span class="toc-number">1.1.2.</span> <span class="toc-text">认识loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css处理的loader"><span class="toc-number">1.1.3.</span> <span class="toc-text">css处理的loader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less文件处理"><span class="toc-number">1.2.</span> <span class="toc-text">less文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#less准备的阶段"><span class="toc-number">1.2.1.</span> <span class="toc-text">less准备的阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#less处理的loader"><span class="toc-number">1.2.2.</span> <span class="toc-text">less处理的loader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源文件处理"><span class="toc-number">1.3.</span> <span class="toc-text">资源文件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#资源准备阶段"><span class="toc-number">1.3.1.</span> <span class="toc-text">资源准备阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url-loader"><span class="toc-number">1.3.2.</span> <span class="toc-text">url-loader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#file-loader"><span class="toc-number">1.3.3.</span> <span class="toc-text">file-loader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#babel-loader"><span class="toc-number">1.4.</span> <span class="toc-text">babel-loader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集成Vuejs"><span class="toc-number">2.</span> <span class="toc-text">集成Vuejs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单使用Vuejs"><span class="toc-number">2.1.</span> <span class="toc-text">简单使用Vuejs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#el和template"><span class="toc-number">2.2.</span> <span class="toc-text">el和template</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue组件化开发"><span class="toc-number">2.3.</span> <span class="toc-text">Vue组件化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue文件封装处理"><span class="toc-number">2.4.</span> <span class="toc-text">.vue文件封装处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plugin的使用"><span class="toc-number">3.</span> <span class="toc-text">plugin的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识plugin"><span class="toc-number">3.1.</span> <span class="toc-text">认识plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加版权的Plugin"><span class="toc-number">3.2.</span> <span class="toc-text">添加版权的Plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打包html的plugin"><span class="toc-number">3.3.</span> <span class="toc-text">打包html的plugin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js压缩的plugin"><span class="toc-number">3.4.</span> <span class="toc-text">js压缩的plugin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搭建本地服务"><span class="toc-number">4.</span> <span class="toc-text">搭建本地服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#搭建本地服务-1"><span class="toc-number">4.1.</span> <span class="toc-text">搭建本地服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块热更新"><span class="toc-number">4.2.</span> <span class="toc-text">模块热更新</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/lin_risheng/assetOne/raw/master/images/webpack_logo.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">codeLinR的博客</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">webpack深入解析下</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2020-02-13 07:09:04"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-13</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/webpack/">webpack</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="loader的使用"><a href="#loader的使用" class="headerlink" title="loader的使用"></a>loader的使用</h2><blockquote>
<p>目前，webpack帮助我们处理的都是js文件。</p>
<p>但我们前面提过，webpack可以将js、图片、css都当成模块来进行处理，下面我们就来学习一下如何处理它们。</p>
</blockquote>
<h3 id="css文件处理"><a href="#css文件处理" class="headerlink" title="css文件处理"></a>css文件处理</h3><h4 id="css准备的阶段"><a href="#css准备的阶段" class="headerlink" title="css准备的阶段"></a>css准备的阶段</h4><p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。</p>
<ul>
<li>在src目录中，创建一个css文件，其中创建一个normal.css文件。</li>
<li>我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。</li>
</ul>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-b9324f15c173ebb9" alt=""></p>
<p>normal.css中的代码非常简单，就是将body设置为red</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-css&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这个时候normal.css中的样式会生效吗？</p>
<ul>
<li>当然不会，因为我们压根就没有引用它。</li>
<li>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。</li>
</ul>
<p>在入口文件中引用：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-4d112916935b5a05" alt=""></p>
<p>重新打包，会出现如下错误：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-8dce437f38f245ef" alt=""></p>
<p>这个错误，告诉我们要想加载css文件，必须使用对应的loader</p>
<h4 id="认识loader"><a href="#认识loader" class="headerlink" title="认识loader"></a>认识loader</h4><p>loader是webpack中一个非常核心的概念。</p>
<p>webpack用来做什么呢？</p>
<ul>
<li>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。</li>
<li>但是，在开发中我们不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</li>
<li>对于webpack本身的能力来说，对于这些转化是不支持的。</li>
<li>那怎么办呢？给webpack扩展对应的loader就可以啦。</li>
</ul>
<p>loader使用过程：</p>
<ul>
<li>步骤一：通过npm安装需要使用的loader</li>
<li>步骤二：在<code>webpack.config.js</code>中的<code>modules</code>关键字下进行配置</li>
</ul>
<p>目前，我们希望加载和使用.css文件，就需要使用对应的loader</p>
<ul>
<li>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</li>
</ul>
<h4 id="css处理的loader"><a href="#css处理的loader" class="headerlink" title="css处理的loader"></a>css处理的loader</h4><p>在webpack的官方中，我们可以找到如下关于样式的loader使用方法：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-20ea504f5971a29e" alt=""></p>
<p>OK，按照教程，我们需要先安装css-loader</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure>

<p>按照官方配置webpack.config.js文件</p>
<ul>
<li>注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</li>
</ul>
<p>重新打包项目：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-55c445148d72b59f" alt=""></p>
<p>但是，运行index.html，你会发现样式并没有生效。</p>
<ul>
<li>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。</li>
<li>这个时候，我们还需要一个style-loader帮助我们处理。</li>
</ul>
<p>我们来安装style-loader</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>

<p>将对应的style-loader，配置在webpack.config.js中</p>
<ul>
<li>注意：style-loader需要放在css-loader的前面。</li>
<li>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？</li>
<li>答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</li>
</ul>
<p>目前，webpack.config.js的配置如下：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 入口: 可以是字符串&#x2F;数组&#x2F;对象, 这里我们入口只有一个,所以写一个字符串即可</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;main.js&#39;,</span><br><span class="line">  &#x2F;&#x2F; 出口: 通常是一个对象, 里面至少包含两个重要属性, path 和 filename</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;dist&#39;), &#x2F;&#x2F; 注意: path通常是一个绝对路径</span><br><span class="line">    filename: &#39;bundle.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: &#x2F;\.css$&#x2F;,</span><br><span class="line">        use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，现在再次运行index.html就会发现我们的样式生效了。</p>
<h3 id="less文件处理"><a href="#less文件处理" class="headerlink" title="less文件处理"></a>less文件处理</h3><blockquote>
<p>如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？</p>
<p>我们这里以less为例，其他也是一样的。</p>
</blockquote>
<h4 id="less准备的阶段"><a href="#less准备的阶段" class="headerlink" title="less准备的阶段"></a>less准备的阶段</h4><p>我们还是先创建一个less文件，依然放在css文件夹中</p>
<p>special.css文件的内容：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-less&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@fontSize: 50px;</span><br><span class="line">@fontColor: white;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    color: @fontColor;</span><br><span class="line">    font-size: @fontSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让special.css生效，我们需要在main.js中引入</p>
<ul>
<li>另外，这里为了看到样式有生效，还在页面中写入了一个div元素</li>
</ul>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-47038588c5b6636b" alt=""></p>
<p>这个时候，打包程序，会报如下错误：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-5549cf35229a4c0a" alt=""></p>
<h4 id="less处理的loader"><a href="#less处理的loader" class="headerlink" title="less处理的loader"></a>less处理的loader</h4><p>继续在官方中查找，我们会找到less-loader相关的使用说明</p>
<p>首先，还是需要安装对应的loader</p>
<ul>
<li>注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less-loader less</span><br></pre></td></tr></table></figure>

<p>其次，修改对应的配置文件</p>
<ul>
<li>添加一个rules选项，用于处理.less文件</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.less$&#x2F;,</span><br><span class="line">    use: [&#123;</span><br><span class="line">        loader: &quot;style-loader&quot; &#x2F;&#x2F; creates style nodes from JS strings</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: &quot;css-loader&quot; &#x2F;&#x2F; translates CSS into CommonJS</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        loader: &quot;less-loader&quot; &#x2F;&#x2F; compiles Less to CSS</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="资源文件处理"><a href="#资源文件处理" class="headerlink" title="资源文件处理"></a>资源文件处理</h3><h4 id="资源准备阶段"><a href="#资源准备阶段" class="headerlink" title="资源准备阶段"></a>资源准备阶段</h4><p>首先，我们在项目中加入两张图片：</p>
<ul>
<li>一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb)</li>
<li>待会儿我们会针对这两张图片进行不同的处理</li>
</ul>
<p>我们先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-css&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: red;</span><br><span class="line">  background: url(..&#x2F;imgs&#x2F;test01.jpeg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们现在直接打包，会出现如下问题</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-b288bf704f7de04a" alt=""></p>
<p>很简单，还是没有对应的加载器</p>
<h4 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h4><p>图片处理，我们使用url-loader来处理</p>
<p>依然先安装url-loader</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js配置文件：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: &#x2F;\.(png|jpg|gif|jpeg)$&#x2F;,</span><br><span class="line">   use: [</span><br><span class="line">     &#123;</span><br><span class="line">       loader: &#39;url-loader&#39;,</span><br><span class="line">       options: &#123;</span><br><span class="line">         limit: 8192</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个limit选项，我们先写在这里，待会儿再来解释它的作用</p>
<p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。</p>
<p>而仔细观察，你会发现背景图是通过base64显示出来的</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-a503ea84cf0e4319" alt=""></p>
<p>OK，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码</p>
<p>那么问题来了，如果大于8kb呢？</p>
<ul>
<li>我们将background的图片改成test02.jpg</li>
</ul>
<p>继续打包我们的程序，报错了</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-cdd6704795f61493" alt=""></p>
<p>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<h4 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h4><p>当图片大于8kb时，会使用file-loader进行加载，所以我们需要先安装file-loader</p>
<ul>
<li>注：file-loader可以不进行rules的配置</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure>

<p>再次打包，就会发现dist文件夹下多了一个图片文件</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-ce1675e6af96012e" alt=""></p>
<p>我们发现webpack自动帮助我们生成一个非常长的名字</p>
<ul>
<li>这是一个32位hash值，目的是防止名字重复</li>
<li>但是，真实开发中，我们可能对打包的图片名字有一定的要求</li>
<li>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复</li>
</ul>
<p>所以，我们可以在options中添加上如下选项：</p>
<ul>
<li>img：文件要打包到的文件夹</li>
<li>name：获取图片原来的名字，放在该位置</li>
<li>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</li>
<li>ext：使用图片原来的扩展名</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    limit: 8192,</span><br><span class="line">    name: &#39;img&#x2F;[name].[hash:8].[ext]&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确</p>
<ul>
<li>默认情况下，webpack会将生成的路径直接返回给使用者</li>
<li>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/</li>
</ul>
<p>在webpack.config.js中添加如下配置：</p>
<ul>
<li>这个配置待会儿就不再需要了，我们后续再说，在这里我们必须添加上去。</li>
</ul>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-2127c880add8399a" alt=""></p>
<p>再次打包运行程序，一切正常了。</p>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。</p>
<p>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。</p>
<ul>
<li>而在webpack中，我们直接使用babel对应的loader就可以了。</li>
</ul>
<p>安装对应的babel-loader</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>配置webpack.config.js文件</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.m?js$&#x2F;,</span><br><span class="line">  exclude: &#x2F;(node_modules|bower_components)&#x2F;,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: &#39;babel-loader&#39;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      presets: [&#39;es2015&#39;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法</p>
<h2 id="集成Vuejs"><a href="#集成Vuejs" class="headerlink" title="集成Vuejs"></a>集成Vuejs</h2><blockquote>
<p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。</p>
<p>所以，下面我们来学习一下如何在我们的webpack环境中集成Vuejs</p>
</blockquote>
<h3 id="简单使用Vuejs"><a href="#简单使用Vuejs" class="headerlink" title="简单使用Vuejs"></a>简单使用Vuejs</h3><p>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装</p>
<ul>
<li>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure>

<p>那么，接下来就可以按照我们之前学习的方式来使用Vue了</p>
<p>我们创建一个Vue实例：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">   el: &#39;#app&#39;,</span><br><span class="line">   data: &#123;</span><br><span class="line">     name: &#39;coderwhy&#39;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>上面的Vue实例中，我们要挂载一个#app对应的元素，所以也要修改index.html</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-512c4268d4dda18d" alt=""></p>
<p>修改完成后，重新打包，运行程序：</p>
<ul>
<li>打包过程没有任何错误(因为只是多打包了一个vue的js文件而已)</li>
<li>但是运行程序，没有出现想要的效果，而且浏览器中有报错</li>
</ul>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-c171d387ab4c99dd" alt=""></p>
<p>这个错误说的是我们使用的是runtime-only版本的Vue，什么意思呢？</p>
<ul>
<li>这个在后续的课程中我具体说明runtime-compiler和runtime-only的区别。</li>
<li>这里我只说解决方案：<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Finstallation.html%23%25E5%25AF%25B9%25E4%25B8%258D%25E5%2590%258C%25E6%259E%2584%25E5%25BB%25BA%25E7%2589%2588%25E6%259C%25AC%25E7%259A%2584%25E8%25A7%25A3%25E9%2587%258A" target="_blank" rel="noopener">Vue不同版本构建</a></li>
<li>所以我们修改webpack的配置，添加如下内容即可</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>重新打包，运行程序：</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-baf1bcb59447d6d0" alt=""></p>
<h3 id="el和template"><a href="#el和template" class="headerlink" title="el和template"></a>el和template</h3><p>正常运行之后，我们来考虑另外一个问题：</p>
<ul>
<li>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</li>
<li>如果我们后面自定义了组件，也必须修改index.html来使用组件</li>
<li>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？</li>
</ul>
<p>定义template属性：</p>
<ul>
<li>在前面的Vue实例中，我们已经定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容</li>
<li>这里，我们可以将div元素中的内容删掉，只保留一个基本的id为div的元素</li>
<li>但是如果我依然希望在其中显示的内容，应该怎么处理呢？</li>
<li>我们可以再定义一个template属性，代码如下：</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  template: &#39;&lt;div id&#x3D;&quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;coderwhy&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重新打包，运行程序，显示一样的结果和HTML代码结构</p>
<p>那么，el和template模板的关系是什么呢？</p>
<ul>
<li>在我们之前的学习中，我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。</li>
<li>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。</li>
</ul>
<p>这样做有什么好处呢？</p>
<ul>
<li>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</li>
</ul>
<p>但是，书写template模块非常麻烦怎么办呢？</p>
<ul>
<li>没有关系，稍后我们会将template模板中的内容进行抽离。</li>
<li>会分成三部分书写：template、script、style，结构变得非常清晰。</li>
</ul>
<h3 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h3><p>在学习组件化开发的时候，我说过以后的Vue开发过程中，我们都会采用组件化开发的思想。</p>
<p>那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？</p>
<p>查看下面的代码：</p>
<ul>
<li>1.定义一个组件对象</li>
<li>2.在Vue实例的components中进行注册</li>
<li>3.在Vue实例的template模板中使用</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const App &#x3D; &#123;</span><br><span class="line">  template: &#39;&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;我是APP组件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &#123;&#123;message&#125;&#125;</span><br><span class="line">      &lt;App&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;coderwhy&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重新打包，运行程序，组件内容正常的显示出来了。</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-0f5505e28337d128" alt=""></p>
<p>为了方便维护我们的App组件，我们可以将对应的代码单独抽离取出</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-2614cd9a71b62709" alt=""></p>
<p>代码依然可以正常运行，没有问题。</p>
<h3 id="vue文件封装处理"><a href="#vue文件封装处理" class="headerlink" title=".vue文件封装处理"></a>.vue文件封装处理</h3><p>但是一个组件以一个js对象的形式进行组织和使用的时候是非常不方便的</p>
<ul>
<li>一方面编写template模块非常的麻烦</li>
<li>另外一方面如果有样式的话，我们写在哪里比较合适呢？</li>
</ul>
<p>现在，我们以一种全新的方式来组织一个vue的组件</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-vue&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2 class&#x3D;&quot;title&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &#39;我是.vue的App组件&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .title &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>但是，这个时候这个文件可以被正确的加载吗？</p>
<ul>
<li>必然不可以，这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</li>
<li>谁来处理呢？vue-loader以及vue-template-compiler。</li>
</ul>
<p>安装vue-loader和vue-template-compiler</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js的配置文件：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">    use: [&#39;vue-loader&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新打包，运行程序，你会发现.vue文件已经可以被识别，并且正确的显示了出来。</p>
<h2 id="plugin的使用"><a href="#plugin的使用" class="headerlink" title="plugin的使用"></a>plugin的使用</h2><h3 id="认识plugin"><a href="#认识plugin" class="headerlink" title="认识plugin"></a>认识plugin</h3><p>plugin是什么？</p>
<ul>
<li>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。</li>
<li>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</li>
</ul>
<p>loader和plugin区别</p>
<ul>
<li>loader主要用于转换某些类型的模块，它是一个转换器。</li>
<li>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</li>
</ul>
<p>plugin的使用过程：</p>
<ul>
<li>步骤一：通过npm安装需要使用的plugins(某些内置插件不需要安装)</li>
<li>步骤二：在webpack.config.js中的plugins中配置插件。</li>
</ul>
<p>下面，我们就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让我们的webpack变得更加好用。</p>
<h3 id="添加版权的Plugin"><a href="#添加版权的Plugin" class="headerlink" title="添加版权的Plugin"></a>添加版权的Plugin</h3><p>我们先来使用一个最简单的插件，为打包的文件添加版权声明</p>
<ul>
<li>该插件名字叫BannerPlugin，属于webpack自带的插件。</li>
</ul>
<p>按照下面的方式来修改webpack.config.js的文件：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.BannerPlugin(&#39;最终版权归coderwhy所有&#39;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新打包程序：查看bundle.js文件的头部，看到如下信息</p>
<p><img src="//upload-images.jianshu.io/upload_images/1102036-255b6409d484dc3f" alt=""></p>
<h3 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h3><p>目前，我们的index.html文件是存放在项目的根目录下的。</p>
<p>我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。</p>
<p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用HtmlWebpackPlugin插件</p>
<p>HtmlWebpackPlugin插件可以为我们做这些事情：</p>
<ul>
<li>自动生成一个index.html文件(可以指定模板来生成)</li>
<li>将打包的js文件，自动通过script标签插入到body中</li>
</ul>
<p>安装HtmlWebpackPlugin插件</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.BannerPlugin(&#39;最终版权归coderwhy所有&#39;),</span><br><span class="line">  new htmlWebpackPlugin(&#123;</span><br><span class="line">    template: &#39;index.html&#39;</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这里的template表示根据什么模板来生成index.html</li>
<li>另外，我们需要删除之前在output中添加的publicPath属性，否则插入的script标签中的src可能会有问题</li>
</ul>
<h3 id="js压缩的plugin"><a href="#js压缩的plugin" class="headerlink" title="js压缩的plugin"></a>js压缩的plugin</h3><p>在项目发布之前，我们必然需要对js等文件进行压缩处理</p>
<p>这里，我们就对打包的js文件进行压缩</p>
<ul>
<li>我们使用一个第三方的插件uglifyjs-webpack-plugin，并且版本号指定1.1.1，和CLI2保持一致</li>
</ul>
<p>安装uglifyjs-webpack-plugin插件：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure>

<p>修改webpack.config.js文件，使用插件：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line">const webpack &#x3D; require(&#39;webpack&#39;)</span><br><span class="line">const uglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.BannerPlugin(&#39;最终版权归coderwhy所有&#39;)</span><br><span class="line">    new uglifyJsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看打包后的bunlde.js文件，是已经被压缩过了。</p>
<h2 id="搭建本地服务"><a href="#搭建本地服务" class="headerlink" title="搭建本地服务"></a>搭建本地服务</h2><blockquote>
<p>现在我们的环境有一个很大的弊端，每次修改了代码都需要手动来编译（当然可以通过watch），另外编译后要刷新页面才能看到对应的效果。</p>
<p>如果代码修改后，可以自动刷新浏览器看到修改后的效果，会大大提升我们的开发效率。</p>
</blockquote>
<h3 id="搭建本地服务-1"><a href="#搭建本地服务-1" class="headerlink" title="搭建本地服务"></a>搭建本地服务</h3><p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</p>
<p>不过它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server@2.9.1</span><br></pre></td></tr></table></figure>

<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</p>
<ul>
<li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</li>
<li>port：端口号</li>
<li>inline：页面实时刷新</li>
<li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li>
</ul>
<p>webpack.config.js文件配置修改如下：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: &#39;.&#x2F;dist&#39;,</span><br><span class="line">  inline: true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>另外，我们再针对开发环境在package.json中配置一个scripts</p>
<ul>
<li>–open参数表示直接打开浏览器</li>
</ul>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-json&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server --open&quot;</span><br></pre></td></tr></table></figure>

<p>通过npm run dev启动环境，就会发现我们已经有了一个可以实时刷新页面的本地服务了。</p>
<h3 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h3><p>搭建完本地服务后固然非常好用，但是它还是存在一个弊端：当只有一部分代码发生变化时，我们去刷新了整个页面。</p>
<p>很明显，如果我们能在修改完代码后只刷新修改的部分，那么界面的更新效率会更高。</p>
<ul>
<li>如何能做到呢？使用HotModuleReplacementPlugin插件即可。</li>
<li>该拆件是一个webpack内置的插件，并不需要安装，直接使用即可</li>
</ul>
<p>在webpack.config.js文件中修改插件如下：</p>
<p>**</p>
<figure class="highlight plain"><figcaption><span>.language-js&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &#39;.&#x2F;dist&#39;,</span><br><span class="line">    inline: true,</span><br><span class="line">    hot: true</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.BannerPlugin(&#39;最终版权归coderwhy所有&#39;),</span><br><span class="line">    new uglifyJsPlugin(),</span><br><span class="line">    new htmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#39;index.html&#39;</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/webpack/">webpack</a><a class="post-meta__tags" href="/tags/%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85/">模块打包</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/lin_risheng/assetOne/raw/master/images/nodejs_logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/15/Vuejs%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%B7%A9%E5%9B%BA%E6%95%B4%E7%90%86/"><img class="prev_cover" src="https://gitee.com/lin_risheng/assetOne/raw/master/images/vuejs_logo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vuejs知识体系巩固整理</div></div></a></div><div class="next-post pull_right"><a href="/2020/02/12/webpack%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"><img class="next_cover" src="https://gitee.com/lin_risheng/assetOne/raw/master/images/webpack_logo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack深入解析 上</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/12/webpack深入解析/" title="webpack深入解析 上"><img class="relatedPosts_cover" src="https://gitee.com/lin_risheng/assetOne/raw/master/images/webpack_logo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-12</div><div class="relatedPosts_title">webpack深入解析 上</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/15/Vuejs知识体系巩固整理/" title="Vuejs知识体系巩固整理"><img class="relatedPosts_cover" src="https://gitee.com/lin_risheng/assetOne/raw/master/images/vuejs_logo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-15</div><div class="relatedPosts_title">Vuejs知识体系巩固整理</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="lv-container" data-id="city" data-uid="MTAyMC81MDA4NC8yNjU3NA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By codeLinR</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>